# Story 7.6: CodeMirror 6 Integration

## Status
In Progress

## Story

**As a** live coder,
**I want** responsive syntax highlighting using CodeMirror 6,
**so that** I can type without lag while seeing highlighted code

## Background

Story 7.5 implemented Prism.js syntax highlighting with overlay architecture (transparent textarea + colored div). This caused 23ms presentation delay per keystroke due to expensive browser repaints. Typing lag was unacceptable for live coding.

**Root cause:** Browser rendering pipeline forced to repaint entire overlay on every keystroke.

**Solution:** Replace textarea + overlay with CodeMirror 6 editor, which uses incremental parsing and virtual scrolling for performance.

## Acceptance Criteria

1. Replace all textareas with CodeMirror 6 EditorView instances
2. Syntax highlighting for JavaScript (Strudel code)
3. No typing lag (<5ms processing per keystroke)
4. Line wrapping respects settings.wrap_lines
5. Auto-formatting works with CodeMirror (Prettier integration)
6. All panel operations work: create, delete, restore session, WebSocket sync
7. Master panel uses CodeMirror
8. Theme: atomone (matches current Atom One Dark colors)

## Implementation Phases

### Phase 1: Core Integration (src/main.js)

**Goal:** Create `createEditorView()` function to instantiate CodeMirror instances

**Tasks:**
- Import CodeMirror packages:
  - `EditorView`, `EditorState` from `@codemirror/view` / `@codemirror/state`
  - `basicSetup` from `@strudel/codemirror`
  - `javascript` from `@codemirror/lang-javascript`
  - `theme` from `@strudel/codemirror/themes.mjs`
  - `EditorView.lineWrapping` from `@codemirror/view`

- Create `createEditorView(container, options)` function:
  ```javascript
  function createEditorView(container, options = {}) {
    const { initialCode = '', onChange = null, panelId = null } = options;
    const settings = getSettings();

    const extensions = [
      basicSetup,
      javascript(),
      theme('atomone'),
    ];

    // Conditional line wrapping
    if (settings.wrap_lines) {
      extensions.push(EditorView.lineWrapping);
    }

    // Update listener for onChange callback
    if (onChange) {
      extensions.push(EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          const code = update.state.doc.toString();
          onChange(code, panelId);
        }
      }));
    }

    const state = EditorState.create({
      doc: initialCode,
      extensions,
    });

    const view = new EditorView({
      state,
      parent: container,
    });

    return view;
  }
  ```

- Create global Map to store editor instances:
  ```javascript
  const editorViews = new Map(); // { panelId: EditorView }
  ```

**Testing:**
- Create single test panel with CodeMirror
- Verify typing is responsive
- Verify syntax highlighting works
- Verify line wrapping toggle works

---

### Phase 2: Panel Manager Integration (src/managers/panelManager.js)

**Goal:** Replace textareas with CodeMirror in all panels

**Tasks:**
- Modify `renderPanel()`:
  - Replace textarea HTML with `<div class="code-editor" data-card="${panelId}"></div>`
  - Return container div (not full panelElement)

- Update panelManager to export container selector:
  ```javascript
  export function getPanelEditorContainer(panelId) {
    return document.querySelector(`.code-editor[data-card="${panelId}"]`);
  }
  ```

- Modify main.js panel initialization:
  ```javascript
  const container = getPanelEditorContainer(panelId);
  const view = createEditorView(container, {
    initialCode: panel.code,
    onChange: handleEditorChange,
    panelId: panelId,
  });
  editorViews.set(panelId, view);
  ```

**Testing:**
- Create new panel
- Verify editor renders correctly
- Verify panel state saves/loads

---

### Phase 3: Event Wiring (src/main.js)

**Goal:** Wire up all event handlers to work with CodeMirror API

**Tasks:**
- Replace textarea input listener with `handleEditorChange()`:
  ```javascript
  function handleEditorChange(code, panelId) {
    const panel = getPanel(panelId);
    if (panel) {
      updatePanel(panelId, { code: code });
      checkStaleness(panelId);
      updateVisualIndicators(panelId);
      updateAllButton();
    }
  }
  ```

- Update `activatePanel()` to work with EditorView:
  ```javascript
  async function activatePanel(panelId) {
    const view = editorViews.get(panelId);
    const code = view.state.doc.toString();

    // Transpile, evaluate, format (same logic)

    // Update editor with formatted code (if auto_format enabled)
    if (formattedCode !== code) {
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: formattedCode
        }
      });
    }
  }
  ```

- Update master panel:
  ```javascript
  // Replace #master-code textarea with div container
  const masterContainer = document.getElementById('master-code-container');
  const masterView = createEditorView(masterContainer, {
    initialCode: masterCode || '',
    onChange: (code) => {
      clearTimeout(masterCodeTimer);
      masterCodeTimer = setTimeout(() => {
        evaluateMasterCode();
      }, 800);
      autoSavePanelState();
    },
    panelId: MASTER_PANEL_ID,
  });
  editorViews.set(MASTER_PANEL_ID, masterView);
  ```

- Update `savePanelState()` to read from EditorView:
  ```javascript
  const masterView = editorViews.get(MASTER_PANEL_ID);
  if (masterView) {
    panelArray.push({
      id: MASTER_PANEL_ID,
      title: 'Master Panel (Global Controls)',
      code: masterView.state.doc.toString(),
      // ...
    });
  }
  ```

- Update `restorePanels()` to initialize editors:
  ```javascript
  panels.forEach(panelConfig => {
    if (panelConfig.id === MASTER_PANEL_ID) {
      const masterView = editorViews.get(MASTER_PANEL_ID);
      masterView.dispatch({
        changes: { from: 0, to: masterView.state.doc.length, insert: panelConfig.code }
      });
    } else {
      const panelId = createPanel(panelConfig);
      renderPanel(panelId);
      const container = getPanelEditorContainer(panelId);
      const view = createEditorView(container, {
        initialCode: panelConfig.code,
        onChange: handleEditorChange,
        panelId: panelId,
      });
      editorViews.set(panelId, view);
    }
  });
  ```

- Update WebSocket `sync_panel` handler:
  ```javascript
  const view = editorViews.get(panelId);
  if (view) {
    view.dispatch({
      changes: { from: 0, to: view.state.doc.length, insert: data.code }
    });
  }
  ```

**Testing:**
- PLAY button works
- Auto-format works
- Staleness detection works
- Session restore works
- WebSocket sync works
- Master panel works

---

### Phase 4: Settings Integration (src/main.js)

**Goal:** Apply settings dynamically (line wrapping, auto-format)

**Tasks:**
- Create `updateEditorSettings()` function:
  ```javascript
  function updateEditorSettings() {
    const settings = getSettings();

    editorViews.forEach((view, panelId) => {
      const currentExtensions = [
        basicSetup,
        javascript(),
        theme('atomone'),
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            const code = update.state.doc.toString();
            handleEditorChange(code, panelId);
          }
        }),
      ];

      if (settings.wrap_lines) {
        currentExtensions.push(EditorView.lineWrapping);
      }

      view.dispatch({
        effects: StateEffect.reconfigure.of(currentExtensions)
      });
    });
  }
  ```

- Call `updateEditorSettings()` when settings change

**Testing:**
- Toggle line wrapping in settings
- Verify all editors update

---

### Phase 5: Cleanup (src/main.js, index.html)

**Goal:** Remove old textarea + overlay code

**Tasks:**
- Remove functions:
  - `attachHighlightListener()`
  - `applyHighlighting()`
  - `highlightCode()` (Prism.js wrapper)

- Remove imports:
  - Prism.js
  - `prettier` (keep, still used for auto-format)

- Remove CSS (index.html):
  - `.code-highlight` styles
  - `.code-editor .code-input { color: transparent; }` rules
  - Prism token classes (`.token.comment`, etc.)

- Remove HTML:
  - `.code-highlight` div from panelManager.js renderPanel()
  - Master panel `.code-highlight` div

**Testing:**
- Full regression test
- Verify no console errors
- Verify typing is responsive

---

## Dependencies

- `@strudel/codemirror@1.2.6` (already installed)
- `@codemirror/view@6.38.7` (via strudel)
- `@codemirror/state@6.5.2` (via strudel)
- `@codemirror/lang-javascript@6.2.4` (via strudel)
- `prettier@3.6.2` (already installed, still used for auto-format)

## Related Stories

- Story 7.5: Syntax Highlighting (replaced due to performance issues)
- Story 7.4: Auto-Formatting (still uses Prettier, now integrates with CodeMirror)
- Story 7.1: Line Wrapping Settings (now applied via CodeMirror extension)

## Out of Scope

- Custom Strudel language mode (use JavaScript syntax for now)
- Auto-complete/IntelliSense (future enhancement)
- Multi-cursor editing (CodeMirror supports, but not wired up)
- Theme customization beyond atomone (future enhancement)

## Performance Notes

**Before (Prism.js + overlay):**
- Input: 1ms
- Processing: 0ms
- Presentation: 23ms
- **Total: 24ms per keystroke**

**After (CodeMirror 6):**
- Target: <5ms total per keystroke
- CodeMirror uses incremental parsing (only re-parse changed lines)
- Virtual scrolling (only render visible lines)
- GPU-accelerated rendering

## Change Log

| Date       | Version | Description          | Author |
|------------|---------|----------------------|--------|
| 2025-11-17 | 1.0     | Initial story draft  | Claude |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None yet - implementation in progress.

### Completion Notes List

- Phase 1: In progress
- Phase 2: Pending
- Phase 3: Pending
- Phase 4: Pending
- Phase 5: Pending

### File List

Files to be modified:
- src/main.js (create createEditorView, wire up event handlers)
- src/managers/panelManager.js (replace textarea HTML with div container)
- index.html (replace master panel textarea, remove overlay CSS)
- package.json (no changes needed, dependencies already installed)

## QA Results

_Results from QA Agent review of the completed story implementation_
