# Story 8.4: Full Panel State Sync on Remote Connect

## Status
Ready for Review

## Story

**As a** remote control user,
**I want** to see all current panels when I connect,
**so that** my remote matches the main interface state

## Acceptance Criteria

1. When remote client connects, server sends `full_state` message
2. `full_state` includes all panels: `[{ id, title, playing, stale }]`
3. Remote client rebuilds entire UI from full state
4. Handles connecting mid-session (panels already created/deleted)
5. Handles reconnection after temporary disconnect

## Tasks / Subtasks

- [ ] **Task 1: Implement full state snapshot function** (AC: 2)
  - [ ] Create `getFullPanelState()` function in `src/managers/panelManager.js`
  - [ ] Collect all panels from `panels` object
  - [ ] Include fields: `id, title, playing, stale, position`
  - [ ] Return array of panel state objects sorted by position
  - [ ] Test: Create 3 panels, verify snapshot includes all 3 with correct data

- [ ] **Task 2: Send full state on WebSocket connection** (AC: 1)
  - [ ] Update `initializeWebSocket()` in WebSocket server
  - [ ] On client connection (`ws.on('connection')`), get full state
  - [ ] Send `full_state` message immediately after connection confirmation
  - [ ] Message payload: `{ type: 'full_state', panels: [...] }`
  - [ ] Test: Connect remote client, verify full_state message received

- [ ] **Task 3: Update remote WebSocket message handler** (AC: 1, 3)
  - [ ] Extend `handleMessage()` in remote.html to handle `full_state` event
  - [ ] Extract panels array from event: `{ panels }`
  - [ ] Call `rebuildRemoteUI(panels)` function
  - [ ] Test: Send mock full_state message, verify UI rebuilds

- [ ] **Task 4: Implement remote UI rebuild function** (AC: 3)
  - [ ] Create `rebuildRemoteUI(panels)` function in remote.html
  - [ ] Clear existing panel controls (except global controls)
  - [ ] Iterate through panels array, create control for each
  - [ ] Restore playing state for each panel (button icon, CSS class)
  - [ ] Initialize `panelStates` object from panels array
  - [ ] Test: Rebuild with 3 panels, verify all appear with correct state

- [ ] **Task 5: Clear existing panels before rebuild** (AC: 3)
  - [ ] Find all `.panel-control` elements in `.panels` container
  - [ ] Remove all existing panel controls (preserve master panel if exists)
  - [ ] Clear `panelStates` object: `panelStates = {}`
  - [ ] Test: Rebuild twice in succession, verify no duplicate panels

- [ ] **Task 6: Restore playing state for each panel** (AC: 2, 3)
  - [ ] For each panel in full state, check `playing` field
  - [ ] If `playing: true`, set button icon to pause (⏸)
  - [ ] If `playing: true`, add `.playing` CSS class to panel control
  - [ ] Initialize `panelStates[id]` with playing state
  - [ ] Test: Connect while panel is playing, verify remote shows playing state

- [ ] **Task 7: Handle stale flag in full state** (AC: 2)
  - [ ] Check `stale` field for each panel in full state
  - [ ] If `stale: true`, add visual indicator (from Epic 6)
  - [ ] Remote UI is control-only, so stale indicator is informational
  - [ ] Test: Connect with stale panel, verify stale indicator appears

- [ ] **Task 8: Handle mid-session connection** (AC: 4)
  - [ ] Full state snapshot includes only currently existing panels
  - [ ] Deleted panels not included in snapshot
  - [ ] Remote client doesn't need special handling for mid-session connect
  - [ ] Test: Create 5 panels, delete 2, connect remote, verify only 3 panels appear

- [ ] **Task 9: Handle reconnection scenario** (AC: 5)
  - [ ] On reconnection, full state is sent again (same as initial connection)
  - [ ] Remote client rebuilds UI from scratch
  - [ ] Any local state from previous connection is discarded
  - [ ] Test: Connect, disconnect, wait 10s, reconnect, verify full state resent

- [ ] **Task 10: Preserve master panel if exists** (AC: 3)
  - [ ] Check if master panel exists in full state
  - [ ] If exists, create master panel control first (before other panels)
  - [ ] Master panel always appears at top of panel list
  - [ ] Test: Full state includes master panel, verify appears first in remote UI

## Dev Notes

### Full State Snapshot Function
[Source: AC: 1, 2]

Collect current panel state from main interface:
```javascript
// src/managers/panelManager.js

export function getFullPanelState() {
  const panelArray = Object.values(panels).map(panel => ({
    id: panel.id,
    title: panel.title,
    playing: cardStates[panel.id]?.playing || false,
    stale: cardStates[panel.id]?.stale || false,
    position: panel.position || 0
  }));

  // Sort by position (master panel first, then by position)
  panelArray.sort((a, b) => {
    if (a.id === 'master') return -1;
    if (b.id === 'master') return 1;
    return a.position - b.position;
  });

  return panelArray;
}
```

### WebSocket Server Integration
[Source: AC: 1]

Send full state on connection:
```javascript
// src/server/websocket.js or main.js WebSocket section

import { getFullPanelState } from './managers/panelManager.js';

wss.on('connection', (ws, req) => {
  console.log(`WebSocket client connected from ${req.socket.remoteAddress}`);

  // Send welcome message
  ws.send(JSON.stringify({
    type: 'server.hello',
    message: 'Connected to r0astr WebSocket',
    timestamp: Date.now()
  }));

  // Send full state immediately after connection
  const fullState = getFullPanelState();
  ws.send(JSON.stringify({
    type: 'full_state',
    panels: fullState,
    timestamp: Date.now()
  }));

  console.log(`Sent full state to client: ${fullState.length} panels`);

  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });

  ws.on('close', () => {
    console.log('WebSocket client disconnected');
  });
});
```

### Full State Message Format
[Source: AC: 2, Epic 8 PRD]

`full_state` event structure:
```json
{
  "type": "full_state",
  "panels": [
    {
      "id": "master",
      "title": "Master Controls",
      "playing": false,
      "stale": false,
      "position": 0
    },
    {
      "id": "panel-1701234567890",
      "title": "808 Bass",
      "playing": true,
      "stale": false,
      "position": 1
    },
    {
      "id": "panel-1701234567891",
      "title": "Melody",
      "playing": false,
      "stale": true,
      "position": 2
    }
  ],
  "timestamp": 1701234567890
}
```

### Remote UI Rebuild Function
[Source: AC: 3, 4, 5]

Clear existing panels and rebuild from full state:
```javascript
function rebuildRemoteUI(panels) {
  console.log('[Remote] Rebuilding UI with', panels.length, 'panels');

  // Clear existing panels (keep .panels container)
  const panelsContainer = document.querySelector('.panels');
  panelsContainer.innerHTML = '';

  // Clear state tracking
  Object.keys(panelStates).forEach(key => delete panelStates[key]);

  // Create panel control for each panel in state
  panels.forEach(panel => {
    const panelElement = createRemotePanelControl(panel);

    // Set playing state
    if (panel.playing) {
      panelElement.classList.add('playing');
      const button = panelElement.querySelector('.panel-button');
      const status = panelElement.querySelector('.status');
      if (button) button.textContent = '⏸';
      if (status) status.textContent = 'Playing';
    }

    // Set stale indicator (if Epic 6 implemented)
    if (panel.stale) {
      panelElement.classList.add('stale');
      // Add visual indicator (amber border, icon, etc.)
    }

    // Add to DOM
    panelsContainer.appendChild(panelElement);

    // Initialize state tracking
    panelStates[panel.id] = {
      playing: panel.playing,
      stale: panel.stale
    };
  });

  console.log('[Remote] UI rebuilt successfully');
}
```

### Updated Panel Control Creation
[Source: Story 8.1, AC: 6]

Update `createRemotePanelControl()` to accept full panel state:
```javascript
function createRemotePanelControl(panel) {
  const { id, title, playing = false, stale = false } = panel;

  const div = document.createElement('div');
  div.className = 'panel-control';
  div.id = `remote-${id}`;
  div.dataset.panelId = id;

  // Add playing class if panel is playing
  if (playing) {
    div.classList.add('playing');
  }

  // Add stale class if panel is stale
  if (stale) {
    div.classList.add('stale');
  }

  const playIcon = playing ? '⏸' : '▶';
  const statusText = playing ? 'Playing' : 'Stopped';

  div.innerHTML = `
    <div class="panel-info">
      <h3>${escapeHtml(title)}</h3>
      <div class="status">${statusText}</div>
    </div>
    <button class="panel-button" data-panel="${id}">${playIcon}</button>
  `;

  return div;
}
```

### WebSocket Message Handler Integration
[Source: remote.html lines 273-293]

Extend existing `handleMessage()` function:
```javascript
function handleMessage(message) {
  const { type } = message;

  console.log('[Remote] Received:', type);

  switch (type) {
    case 'server.hello':
      console.log('[Remote] Server hello:', message);
      break;

    case 'full_state':
      // New handler for this story
      handleFullState(message);
      break;

    case 'state.update':
      // Existing incremental state update
      if (message.panels) {
        message.panels.forEach(({ panel, playing }) => {
          panelStates[panel] = playing;
          updatePanelUI(panel, playing);
        });
      }
      break;

    case 'panel_created':
      handlePanelCreated(message);
      break;

    case 'panel_deleted':
      handlePanelDeleted(message);
      break;

    case 'panel_renamed':
      handlePanelRenamed(message);
      break;

    // Additional cases...
  }
}

function handleFullState({ panels }) {
  console.log('[Remote] Received full state:', panels.length, 'panels');
  rebuildRemoteUI(panels);
}
```

### Stale Indicator Integration
[Source: AC: 7, Epic 6]

If Epic 6 (Staleness Detection) is implemented, display stale indicator:

CSS for stale panels:
```css
.panel-control.stale {
  border-color: #FFA726; /* Amber border */
}

.panel-control.stale .panel-info h3::after {
  content: ' ⚠';
  color: #FFA726;
  font-size: 16px;
  margin-left: 4px;
}

.panel-control.stale .status::before {
  content: 'Code Changed • ';
  color: #FFA726;
}
```

Remote UI is control-only (no code editing), so stale indicator is purely informational.

### Mid-Session Connection Scenario
[Source: AC: 4]

User workflow:
1. Main interface starts, creates 5 panels
2. User deletes panels 2 and 4 (3 panels remain)
3. Remote client connects (mid-session)
4. Server sends `full_state` with 3 panels (deleted panels not included)
5. Remote UI shows 3 panels matching current main interface state

No special handling needed - full state snapshot only includes existing panels.

### Reconnection Scenario
[Source: AC: 5]

User workflow:
1. Remote client connects, receives full state
2. Network drops, WebSocket disconnects
3. Auto-reconnect triggers after 1-3 seconds
4. New WebSocket connection established
5. Server sends `full_state` again (same as initial connection)
6. Remote UI rebuilds from fresh state

Remote client treats reconnection same as initial connection - no state carryover.

### Master Panel Handling
[Source: AC: 10, Story 1.3]

Master panel is special case:
- ID: "master"
- Always appears first in panel list (position 0)
- Full state array is sorted by position (master first)

Remote UI rebuild respects order from full state array, so master panel automatically appears first.

### Performance Considerations

**Full state message size:**
- Average panel state: ~100 bytes JSON
- 10 panels: ~1 KB
- 100 panels: ~10 KB
- Minimal network overhead

**Rebuild time:**
- DOM clear: O(n) where n = existing panels
- Panel creation: O(m) where m = new panels
- Total: O(n + m), typically < 50ms for 10 panels

### Testing Edge Cases

Test scenarios for robust full state sync:

- [ ] Connect with 0 panels (empty state)
- [ ] Connect with 1 panel
- [ ] Connect with 10+ panels
- [ ] Connect while panels are playing
- [ ] Connect while panels are stale
- [ ] Connect, disconnect, reconnect (verify fresh state)
- [ ] Connect mid-session (after panels created/deleted)
- [ ] Multiple remote clients connect simultaneously
- [ ] Full state with master panel
- [ ] Full state without master panel

### Interaction with Incremental Updates

**Full state vs incremental updates:**

Full state (`full_state`):
- Sent once on connection
- Complete snapshot of all panels
- Rebuilds entire UI

Incremental updates (`panel_created`, `panel_deleted`, etc.):
- Sent continuously during session
- Single panel changes
- Updates specific UI elements

After receiving `full_state`, remote client listens for incremental updates to stay synchronized.

Timeline example:
```
T0: Remote connects
T1: Server sends full_state (3 panels)
T2: Remote rebuilds UI
T3: User creates panel 4 → server sends panel_created
T4: Remote adds panel 4 to UI (incremental)
T5: User deletes panel 2 → server sends panel_deleted
T6: Remote removes panel 2 from UI (incremental)
```

### Testing

Manual testing checklist:

- [ ] Start main interface, create 3-4 panels
- [ ] Set one panel to playing state
- [ ] Open remote.html in separate browser window
- [ ] Verify `full_state` message received immediately after connection
- [ ] Verify remote UI shows all panels from main interface
- [ ] Verify panel titles match main interface
- [ ] Verify playing panel shows pause icon and "Playing" status
- [ ] Verify panel order matches main interface
- [ ] Close remote.html, wait 5s, reopen
- [ ] Verify full state resent on reconnection
- [ ] Create panel in main interface (mid-session)
- [ ] Delete panel in main interface
- [ ] Connect new remote client
- [ ] Verify remote shows current state (not historical state)
- [ ] Test with 0 panels (empty state)
- [ ] Test with 10+ panels
- [ ] Test with master panel present
- [ ] Verify no duplicate panels after multiple reconnections

### Dependencies

- Story 1.1: Add New Panel Button (panel state structure)
- Story 5.6: WebSocket State Sync (WebSocket infrastructure)
- Story 8.1: Remote UI Updates on Panel Creation (createRemotePanelControl function)
- Epic 6: Staleness Detection (optional stale flag support)

### Related Stories

- Story 8.1: Remote UI Updates on Panel Creation
- Story 8.2: Remote UI Updates on Panel Deletion
- Story 8.3: Remote UI Updates on Panel Rename
- Story 8.5: Remote Panel Order Synchronization

## Change Log

| Date       | Version | Description          | Author |
|------------|---------|----------------------|--------|
| 2025-11-16 | 1.0     | Initial story draft  | Claude |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None - Implementation completed without issues

### Completion Notes List

- Implemented full state broadcast in src/main.js (line 1593-1608):
  - Collects all panels from getAllPanels()
  - Maps to full state objects with id, title, playing, stale, position
  - Sends full_state message immediately after WebSocket connection
  - Includes timestamp for debugging
- Updated createRemotePanelControl() in remote.html (line 295-330):
  - Accepts playing and stale parameters with defaults
  - Sets playing class and pause icon if panel is playing
  - Sets stale class if panel is stale
  - Shows correct status text based on playing state
- Created rebuildRemoteUI() function in remote.html (line 429-461):
  - Clears all existing panels from DOM
  - Clears panelStates object completely
  - Recreates all panels from full state array
  - Removes fade-in animation for rebuilds (instant appearance)
  - Initializes panelStates for each panel
- Extended handleMessage() in remote.html to handle full_state events (line 524-530)
- Full state sync handles:
  - Mid-session connection (shows current panels only)
  - Reconnection (rebuilds from fresh state)
  - Playing state restoration (panels show pause icon if playing)
  - Stale state indication (stale class applied)

### File List

- `src/main.js` (modified) - Added full_state broadcast on WebSocket connection (line 1593-1608)
- `remote.html` (modified) - Updated createRemotePanelControl() to handle playing/stale state (line 295-330)
- `remote.html` (modified) - Added rebuildRemoteUI() function (line 429-461)
- `remote.html` (modified) - Extended handleMessage() to handle full_state event (line 524-530)

## QA Results

_Results from QA Agent review of the completed story implementation_
