<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>r0astr Remote Control</title>

  <!-- Base remote styles -->
  <link rel="stylesheet" href="/css/remote-base.css">

  <!-- Skin-specific remote styles (loaded dynamically) -->
  <link id="skin-remote-css" rel="stylesheet" href="">

  <script>
    // Load skin-specific remote.css based on user preference
    (function loadRemoteSkin() {
      try {
        const settingsKey = 'r0astr_settings';
        const settings = JSON.parse(localStorage.getItem(settingsKey) || '{}');
        const skinName = settings.skin || 'default';

        const link = document.getElementById('skin-remote-css');
        link.href = `/skins/${skinName}/remote.css`;

        // Handle missing remote.css gracefully (skin may not have one)
        link.onerror = () => {
          console.log(`[Remote] No remote.css for skin '${skinName}', using base styles`);
          link.remove();
        };

        console.log(`[Remote] Loading skin: ${skinName}`);
      } catch (e) {
        console.warn('[Remote] Failed to load skin preference:', e);
      }
    })();
  </script>
</head>

<body>
  <!-- Banner Bar -->
  <div class="remote-banner">
    <h1>r0astr</h1>
    <div class="connection-status disconnected" id="status">Connecting...</div>
  </div>

  <!-- Metronome - flush under banner -->
  <div class="remote-metronome" id="remote-metronome">
    <div class="step-box" data-step="0"></div>
    <div class="step-box" data-step="1"></div>
    <div class="step-box" data-step="2"></div>
    <div class="step-box" data-step="3"></div>
    <div class="step-box" data-step="4"></div>
    <div class="step-box" data-step="5"></div>
    <div class="step-box" data-step="6"></div>
    <div class="step-box" data-step="7"></div>
    <div class="step-box" data-step="8"></div>
    <div class="step-box" data-step="9"></div>
    <div class="step-box" data-step="10"></div>
    <div class="step-box" data-step="11"></div>
    <div class="step-box" data-step="12"></div>
    <div class="step-box" data-step="13"></div>
    <div class="step-box" data-step="14"></div>
    <div class="step-box" data-step="15"></div>
  </div>

  <div class="container">
    <div class="master-sliders-remote" id="master-sliders-remote">
      <!-- Master panel sliders appear here dynamically -->
    </div>

    <!-- Masonry grid for panels -->
    <div class="panels-grid" id="panels-grid">
      <!-- Panels populated dynamically - use data-size="1" for plain, data-size="3" for sliders -->
    </div>

    <div class="global-controls">
      <button class="update-all-btn" id="update-all" disabled>UPDATE ALL</button>
      <button class="stop-all-btn" id="stop-all">‚èπ STOP ALL</button>
    </div>
  </div>

  <script>
    // Version tag
    const REMOTE_VERSION = '8.4.0-full-state-sync';
    console.log(`%cüéÆ r0astr Remote ${REMOTE_VERSION}`, 'font-weight: bold; font-size: 14px; color: #51cf66;');

    let ws = null;
    let reconnectTimer = null;

    // Story 8.4: Panel state tracking (dynamically populated from full_state)
    const panelStates = {};

    /**
     * Story 8.1: Escape HTML to prevent XSS
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Story 8.1: Create remote panel control element
     * Grid item: size-1 (square) for plain, size-3 (wide) for panels with sliders
     * @param {Object} panel - Panel data {id, title, position, hasSliders}
     * @returns {HTMLElement} Panel control element
     */
    function createRemotePanelControl(panel) {
      const { id, title, playing = false, stale = false, hasSliders = false } = panel;

      const div = document.createElement('div');
      // Default to size-1 (square), will be upgraded to size-3 when sliders arrive
      div.className = `panel-control panel-control-new ${hasSliders ? 'size-3' : 'size-1'}`;
      div.id = `remote-${id}`;
      div.dataset.panelId = id;
      div.dataset.size = hasSliders ? '3' : '1';

      // Story 8.4: Add playing class if panel is playing
      if (playing) {
        div.classList.add('playing');
      }

      // Story 8.4: Add stale class if panel is stale
      if (stale) {
        div.classList.add('stale');
      }

      const playIcon = playing ? '‚è∏' : '‚ñ∂';

      // Grid layout: button on left, sliders on right (for size-3)
      div.innerHTML = `
          <button class="panel-button" data-panel="${id}" title="${escapeHtml(title)}">${playIcon}</button>
          <div class="panel-sliders-remote" id="panel-sliders-${id}"></div>
        `;

      // Remove animation class after transition completes
      div.addEventListener('animationend', () => {
        div.classList.remove('panel-control-new');
      }, { once: true });

      return div;
    }

    /**
     * Upgrade panel to size-3 when sliders are received
     * @param {string} panelId - Panel ID
     */
    function upgradePanelToWide(panelId) {
      const panel = document.getElementById(`remote-${panelId}`);
      if (panel && panel.dataset.size !== '3') {
        panel.classList.remove('size-1');
        panel.classList.add('size-3');
        panel.dataset.size = '3';
        console.log(`[Remote] Panel ${panelId} upgraded to wide layout`);
      }
    }

    /**
     * Downgrade panel to size-1 when sliders are cleared
     * @param {string} panelId - Panel ID
     */
    function downgradePanelToSquare(panelId) {
      const panel = document.getElementById(`remote-${panelId}`);
      if (panel && panel.dataset.size !== '1') {
        panel.classList.remove('size-3');
        panel.classList.add('size-1');
        panel.dataset.size = '1';
        console.log(`[Remote] Panel ${panelId} downgraded to square layout`);
      }
    }

    /**
     * Story 8.1: Insert panel at correct position in grid
     * @param {HTMLElement} panelElement - Panel element to insert
     * @param {number} position - Position in list (1-indexed)
     */
    function insertPanelAtPosition(panelElement, position) {
      const container = document.getElementById('panels-grid');
      const existingPanels = Array.from(container.querySelectorAll('.panel-control'));

      // Find insertion point based on position
      let insertBefore = null;
      for (const panel of existingPanels) {
        const panelPosition = parseInt(panel.dataset.position) || Infinity;
        if (position < panelPosition) {
          insertBefore = panel;
          break;
        }
      }

      if (insertBefore) {
        container.insertBefore(panelElement, insertBefore);
      } else {
        container.appendChild(panelElement);
      }

      // Store position in dataset
      panelElement.dataset.position = position;
    }

    /**
     * Story 8.2: Remove remote panel control with fade-out animation
     * @param {string} panelId - Panel ID to remove
     */
    function removeRemotePanelControl(panelId) {
      const panelElement = document.querySelector(`#remote-${panelId}`);

      // Task 5: Handle non-existent panel
      if (!panelElement) {
        console.warn('[Remote] Panel not found for deletion:', panelId);
        return;
      }

      // Task 8: Check if already being removed (prevent duplicate removal)
      if (panelElement.classList.contains('panel-control-removing')) {
        console.log('[Remote] Panel already being removed:', panelId);
        return;
      }

      // Task 3: Add removing class to trigger fade-out animation
      panelElement.classList.add('panel-control-removing');

      // Wait for animation to complete, then remove from DOM
      panelElement.addEventListener('animationend', () => {
        panelElement.remove();
        console.log('[Remote] Panel removed:', panelId);
      }, { once: true });

      // Task 4: Clean up panel state tracking
      delete panelStates[panelId];
    }

    /**
     * Story 8.3: Update remote panel title with visual feedback
     * @param {string} panelId - Panel ID to update
     * @param {string} newTitle - New title text
     */
    function updateRemotePanelTitle(panelId, newTitle) {
      const panelElement = document.querySelector(`#remote-${panelId}`);

      // Task 6: Handle non-existent panel
      if (!panelElement) {
        console.warn('[Remote] Panel not found for title update:', panelId);
        return;
      }

      // Find title element (h3)
      const titleElement = panelElement.querySelector('h3');
      if (!titleElement) {
        console.warn('[Remote] Title element not found:', panelId);
        return;
      }

      // Task 5: Sanitize title (XSS prevention)
      const sanitizedTitle = String(newTitle).substring(0, 50).trim() || 'Untitled';

      // Update title using textContent (prevents HTML injection)
      titleElement.textContent = sanitizedTitle;

      // Task 7: Add flash animation for visual feedback
      titleElement.classList.add('title-updated');
      setTimeout(() => {
        titleElement.classList.remove('title-updated');
      }, 600);

      console.log('[Remote] Title updated:', panelId, sanitizedTitle);
    }

    /**
     * Story 8.4: Rebuild entire remote UI from full state
     * @param {Array} panels - Array of panel state objects
     */
    function rebuildRemoteUI(panels) {
      console.log('[Remote] Rebuilding UI with', panels.length, 'panels');

      // Clear existing panels (keep grid container)
      const panelsContainer = document.getElementById('panels-grid');
      panelsContainer.innerHTML = '';

      // Clear state tracking
      Object.keys(panelStates).forEach(key => delete panelStates[key]);

      // Create panel control for each panel in state
      panels.forEach(panel => {
        const panelElement = createRemotePanelControl(panel);

        // Remove animation class for full state rebuild (no fade-in needed)
        panelElement.classList.remove('panel-control-new');

        // Add to DOM
        panelsContainer.appendChild(panelElement);

        // Initialize state tracking
        panelStates[panel.id] = {
          playing: panel.playing || false,
          stale: panel.stale || false
        };
      });

      // Update UPDATE ALL button state
      updateUpdateAllButton();

      console.log('[Remote] UI rebuilt successfully');
    }

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;

      console.log('[Remote] Connecting to:', wsUrl);
      updateConnectionStatus('connecting');

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('[Remote] Connected');
        updateConnectionStatus('connected');

        // Register as remote control client
        ws.send(JSON.stringify({
          type: 'client.register',
          clientType: 'remote'
        }));

        // Clear reconnect timer
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          // Debug: log raw metronome messages
          if (message.type === 'metronome.step' && message.step === 0) {
            console.log('[Remote] RAW ws.onmessage metronome.step:', message);
          }
          handleMessage(message);
        } catch (error) {
          console.error('[Remote] Failed to parse message:', error);
        }
      };

      ws.onerror = (error) => {
        console.error('[Remote] WebSocket error:', error);
      };

      ws.onclose = () => {
        console.log('[Remote] Disconnected - reconnecting in 3s');
        ws = null;
        updateConnectionStatus('disconnected');

        // Auto-reconnect
        reconnectTimer = setTimeout(() => {
          connectWebSocket();
        }, 3000);
      };
    }

    function handleMessage(message) {
      const { type, panels } = message;

      // Don't log every metronome step to avoid spam
      if (type !== 'metronome.step') {
        console.log('[Remote] Received:', type);
      }

      switch (type) {
        case 'server.hello':
          console.log('[Remote] Server hello:', message);
          break;

        case 'full_state':
          // Story 8.4: Rebuild UI from full state
          if (panels) {
            console.log('[Remote] Received full state:', panels.length, 'panels');
            rebuildRemoteUI(panels);
          }
          break;

        case 'state.update':
          // Update all panel states
          if (panels) {
            panels.forEach(({ panel, playing, stale }) => {
              panelStates[panel] = { playing, stale: stale || false };
              updatePanelUI(panel, playing);
            });
            updateUpdateAllButton();
          }
          break;

        case 'panel_created':
          // Story 8.1: Handle dynamically created panels
          const { id, title, position } = message;
          console.log(`[Remote] Panel created: ${id} (${title})`);

          // Story 8.1 Task 7: Check for duplicate panel
          if (document.getElementById(`remote-${id}`)) {
            console.warn(`[Remote] Panel ${id} already exists, skipping creation`);
            break;
          }

          // Create panel control element
          const panelElement = createRemotePanelControl({ id, title, position });

          // Insert at correct position
          insertPanelAtPosition(panelElement, position);

          // Story 8.1 Task 8: Initialize panel state
          panelStates[id] = { playing: false };

          console.log(`[Remote] Panel ${id} added to UI at position ${position}`);
          break;

        case 'panel_deleted':
          // Story 8.2: Handle panel deletion
          const deletedId = message.id;
          console.log(`[Remote] Panel deleted: ${deletedId}`);
          removeRemotePanelControl(deletedId);
          break;

        case 'panel_renamed':
          // Story 8.3: Handle panel rename
          const { id: renamedId, newTitle } = message;
          console.log(`[Remote] Panel renamed: ${renamedId} -> ${newTitle}`);
          updateRemotePanelTitle(renamedId, newTitle);
          break;

        case 'master.sliders':
          // Render master panel sliders from metadata
          if (message.sliders) {
            console.log(`[Remote] Received ${message.sliders.length} master sliders`);
            renderRemoteSliders(message.sliders);
          }
          break;

        case 'master.sliderValue':
          // Update individual slider value
          if (message.sliderId !== undefined && message.value !== undefined) {
            updateRemoteSliderValue(message.sliderId, message.value);
          }
          break;

        case 'panel.sliders':
          // Render panel sliders from metadata
          if (message.panelId && message.sliders) {
            console.log(`[Remote] Received ${message.sliders.length} sliders for panel ${message.panelId}`);
            renderPanelSliders(message.panelId, message.sliders);
          }
          break;

        case 'panel.sliderValue':
          // Update individual panel slider value
          if (message.panelId && message.sliderId !== undefined && message.value !== undefined) {
            updatePanelSliderValue(message.panelId, message.sliderId, message.value);
          }
          break;

        case 'metronome.step':
          // Update metronome visualization
          // Debug: log every 4th step to avoid spam
          if (message.step % 4 === 0) {
            console.log('[Remote] Metronome step:', message.step);
          }
          updateMetronome(message.step, message.isDownbeat, message.active);
          break;
      }
    }

    /**
     * Update metronome step visualization
     * @param {number} step - Current step (0-15), or -1 if stopped
     * @param {boolean} isDownbeat - True if this is a downbeat (0, 4, 8, 12)
     * @param {boolean} active - False when metronome is stopped
     */
    let lastMetronomeStep = -1;
    function updateMetronome(step, isDownbeat, active) {
      const metronome = document.getElementById('remote-metronome');
      if (!metronome) return;

      const stepBoxes = metronome.querySelectorAll('.step-box');

      // Handle stop state
      if (step === -1 || active === false) {
        metronome.classList.remove('active');
        stepBoxes.forEach(box => box.classList.remove('active', 'beat'));
        lastMetronomeStep = -1;
        return;
      }

      // Activate metronome
      metronome.classList.add('active');

      // Only update if step changed
      if (step === lastMetronomeStep) return;
      lastMetronomeStep = step;

      // Update step boxes
      stepBoxes.forEach((box, index) => {
        if (index === step) {
          box.classList.add('active');
          // Brief beat flash
          box.classList.add('beat');
          setTimeout(() => box.classList.remove('beat'), 50);
        } else {
          box.classList.remove('active');
        }
      });

      // Downbeat emphasis
      if (isDownbeat) {
        metronome.classList.add('downbeat');
        setTimeout(() => metronome.classList.remove('downbeat'), 80);
      }
    }

    function updateConnectionStatus(status) {
      const statusEl = document.getElementById('status');
      statusEl.classList.remove('connected', 'disconnected');

      if (status === 'connected') {
        statusEl.textContent = 'üü¢ Connected';
        statusEl.classList.add('connected');
      } else if (status === 'disconnected') {
        statusEl.textContent = 'üî¥ Disconnected';
        statusEl.classList.add('disconnected');
      } else {
        statusEl.textContent = 'üü° Connecting...';
      }
    }

    /**
     * Story 8.4: Update panel UI based on playing state
     * @param {string} panelId - Full panel ID (e.g., panel-1763389957952)
     * @param {boolean} playing - Playing state
     */
    function updatePanelUI(panelId, playing) {
      const panelEl = document.getElementById(`remote-${panelId}`);

      if (!panelEl) {
        console.warn(`[Remote] Panel not found for state update: ${panelId}`);
        return;
      }

      const buttonEl = panelEl.querySelector('.panel-button');
      const statusEl = panelEl.querySelector('.status');

      if (playing) {
        panelEl.classList.add('playing');
        if (buttonEl) buttonEl.textContent = '‚è∏';
        if (statusEl) statusEl.textContent = 'Playing';
      } else {
        panelEl.classList.remove('playing');
        if (buttonEl) buttonEl.textContent = '‚ñ∂';
        if (statusEl) statusEl.textContent = 'Stopped';

        // Clear sliders when panel stops and downgrade to square
        const slidersContainer = document.getElementById(`panel-sliders-${panelId}`);
        if (slidersContainer) {
          slidersContainer.innerHTML = '';
          downgradePanelToSquare(panelId);
        }
      }
    }

    /**
     * Update UPDATE ALL button state based on stale panels
     * Only enabled if there are stale panels that are also playing
     */
    function updateUpdateAllButton() {
      const updateAllBtn = document.getElementById('update-all');
      // Count stale panels that are also playing
      const stalePanelCount = Object.values(panelStates).filter(s => s.stale && s.playing).length;

      if (stalePanelCount > 0) {
        updateAllBtn.disabled = false;
        updateAllBtn.textContent = `UPDATE ALL (${stalePanelCount})`;
      } else {
        updateAllBtn.disabled = true;
        updateAllBtn.textContent = 'UPDATE ALL';
      }
    }

    /**
     * Render master panel sliders from metadata
     * @param {Array} sliders - Array of slider metadata objects
     */
    function renderRemoteSliders(sliders) {
      const container = document.getElementById('master-sliders-remote');
      container.innerHTML = '';

      if (!sliders || sliders.length === 0) {
        return;
      }

      sliders.forEach(({ sliderId, varName, value, min, max }) => {
        const sliderControl = document.createElement('div');
        sliderControl.className = 'remote-slider-control';

        sliderControl.innerHTML = `
            <label>
              <span>${varName}</span>
              <span class="remote-slider-value" data-slider="${sliderId}">${value.toFixed(2)}</span>
            </label>
            <input type="range"
              min="${min}"
              max="${max}"
              step="${(max - min) / 1000}"
              value="${value}"
              data-slider-id="${sliderId}">
          `;

        const input = sliderControl.querySelector('input');
        input.addEventListener('input', (e) => {
          const newValue = parseFloat(e.target.value);

          // Update local display immediately
          const valueDisplay = sliderControl.querySelector('.remote-slider-value');
          if (valueDisplay) {
            valueDisplay.textContent = newValue.toFixed(2);
          }

          // Send change to main UI
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'master.sliderChange',
              sliderId,
              value: newValue
            }));
          }
        });

        container.appendChild(sliderControl);
      });
    }

    /**
     * Update individual slider value from broadcast
     * @param {string} sliderId - Slider ID
     * @param {number} value - New value
     */
    function updateRemoteSliderValue(sliderId, value) {
      const valueDisplay = document.querySelector(`.remote-slider-value[data-slider="${sliderId}"]`);
      if (valueDisplay) {
        valueDisplay.textContent = value.toFixed(2);
      }

      const sliderInput = document.querySelector(`input[data-slider-id="${sliderId}"]`);
      if (sliderInput) {
        sliderInput.value = value;
      }
    }

    /**
     * Render panel-specific sliders
     * @param {string} panelId - Panel ID
     * @param {Array} sliders - Slider metadata array
     */
    function renderPanelSliders(panelId, sliders) {
      const container = document.getElementById(`panel-sliders-${panelId}`);
      if (!container) {
        console.warn(`[Remote] Panel sliders container not found for ${panelId}`);
        return;
      }

      container.innerHTML = '';

      if (!sliders || sliders.length === 0) {
        // No sliders - downgrade to square
        downgradePanelToSquare(panelId);
        return;
      }

      // Has sliders - upgrade to wide layout
      upgradePanelToWide(panelId);

      // console.log(`[Remote SLIDER DEBUG] Rendering ${sliders.length} sliders for ${panelId}:`, sliders);

      sliders.forEach(({ sliderId, label, value, min, max, step }) => {
        // Ensure value is numeric (parse if string, fallback to 0 if invalid)
        let numericValue;
        if (typeof value === 'number' && !isNaN(value)) {
          numericValue = value;
        } else if (typeof value === 'string') {
          numericValue = parseFloat(value);
          if (isNaN(numericValue)) numericValue = 0;
        } else {
          numericValue = 0;
        }
        // console.log(`[Remote SLIDER DEBUG] Slider ${sliderId}: value=${value} (type: ${typeof value}), numericValue=${numericValue}`);

        const sliderControl = document.createElement('div');
        sliderControl.className = 'panel-slider-control';

        sliderControl.innerHTML = `
            <label>
              ${label}:
              <span class="slider-value" data-panel-slider="${panelId}-${sliderId}">${numericValue.toFixed(2)}</span>
            </label>
            <input type="range"
              min="${min}"
              max="${max}"
              step="${step}"
              value="${numericValue}"
              data-panel-id="${panelId}"
              data-panel-slider-id="${sliderId}">
          `;

        const input = sliderControl.querySelector('input');
        input.addEventListener('input', (e) => {
          const newValue = parseFloat(e.target.value);

          // Update local display immediately
          const valueDisplay = sliderControl.querySelector('.slider-value');
          if (valueDisplay) {
            valueDisplay.textContent = newValue.toFixed(2);
          }

          // Send change to main UI
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'panel.sliderChange',
              panelId,
              sliderId,
              value: newValue
            }));
          }
        });

        container.appendChild(sliderControl);
      });
    }

    /**
     * Update individual panel slider value from broadcast
     * @param {string} panelId - Panel ID
     * @param {string} sliderId - Slider ID
     * @param {number} value - New value
     */
    function updatePanelSliderValue(panelId, sliderId, value) {
      const valueDisplay = document.querySelector(`[data-panel-slider="${panelId}-${sliderId}"]`);
      if (valueDisplay) {
        valueDisplay.textContent = value.toFixed(2);
      }

      const sliderInput = document.querySelector(`input[data-panel-id="${panelId}"][data-panel-slider-id="${sliderId}"]`);
      if (sliderInput) {
        sliderInput.value = value;
      }
    }

    function sendCommand(type, panel = null) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.warn('[Remote] WebSocket not connected');
        return;
      }

      const message = { type };
      if (panel !== null) {
        message.panel = panel;
      }

      ws.send(JSON.stringify(message));
      console.log('[Remote] Sent:', message);
    }

    // Story 8.1 Task 5: Use event delegation for panel buttons (supports dynamic panels)
    document.getElementById('panels-grid').addEventListener('click', (e) => {
      const button = e.target.closest('.panel-button');
      if (button) {
        const panelId = button.dataset.panel;
        sendCommand('panel.toggle', panelId);
        console.log(`[Remote] Toggled panel: ${panelId}`);
      }
    });

    // Attach stop-all button listener
    document.getElementById('stop-all').addEventListener('click', () => {
      sendCommand('global.stopAll');
    });

    // Attach update-all button listener
    document.getElementById('update-all').addEventListener('click', () => {
      const updateAllBtn = document.getElementById('update-all');
      if (!updateAllBtn.disabled) {
        sendCommand('global.updateAll');
      }
    });

    // Initialize WebSocket connection
    connectWebSocket();
  </script>
</body>

</html>