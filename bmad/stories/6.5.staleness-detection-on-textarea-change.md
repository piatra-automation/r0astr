# Story 6.5: Staleness Detection on Textarea Change

## Status
Ready for Review

## Story

**As a** developer,
**I want** staleness to be set immediately when user edits textarea,
**so that** the UI updates in real-time

## Acceptance Criteria

1. `input` event listener on panel textarea
2. Event handler compares current textarea value to last-evaluated code
3. If different AND panel playing, set stale=true
4. If identical, set stale=false
5. UI updates immediately (no debounce delay)

## Tasks / Subtasks

- [x] **Task 1: Attach input event listener to textareas** (AC: 1)
  - [x] Select all `.code-input` textareas on page load
  - [x] Attach `input` event listener to each textarea
  - [x] Extract `panelId` from `data-card` attribute
  - [x] Ensure listeners work with dynamic panels (Epic 1)

- [x] **Task 2: Implement textarea change handler** (AC: 1, 2, 3, 4)
  - [x] Create `onTextareaChange(panelId)` function
  - [x] Get current textarea value: `textarea.value`
  - [x] Get last-evaluated code: `panel.lastEvaluatedCode`
  - [x] Compare values with strict equality: `===`
  - [x] Call `checkStaleness(panelId)` to update stale flag

- [x] **Task 3: Ensure immediate UI update** (AC: 5)
  - [x] Call `updateVisualIndicators(panelId)` after staleness check
  - [x] Call `updateAllButton()` to refresh UPDATE ALL state
  - [x] No debounce or throttle (immediate feedback)
  - [x] Test: Type one character → UI updates instantly

- [x] **Task 4: Handle edge case: restore original code** (AC: 4)
  - [x] User edits code → stale=true
  - [x] User undo/restore original → stale=false
  - [x] Comparison is exact: whitespace matters
  - [x] Test: Add space, remove space → stale cleared

- [x] **Task 5: Integrate with existing checkStaleness()** (AC: 2, 3, 4)
  - [x] Reuse `checkStaleness(panelId)` from Story 6.1
  - [x] Ensure function handles playing vs. paused panels correctly
  - [x] Staleness only applies to playing panels
  - [x] Test: Edit paused panel → stale remains false

- [x] **Task 6: Use event delegation for dynamic panels** (AC: 1)
  - [x] Attach single `input` listener to `document` or container
  - [x] Check if event target is `.code-input` textarea
  - [x] Extract `panelId` from `data-card` attribute
  - [x] Call `onTextareaChange(panelId)`
  - [x] Ensures new panels (Epic 1) automatically get listener

- [x] **Task 7: Handle programmatic textarea updates** (AC: 1, 2)
  - [x] Programmatic updates (e.g., load from settings) should NOT trigger staleness
  - [x] Use `textarea.value = code` (does NOT fire `input` event)
  - [x] Only user typing/pasting triggers `input` event
  - [x] Test: Restore settings → textareas update without staleness

- [ ] **Task 8: Add performance optimization** (AC: 5, optional)
  - [ ] Consider debouncing if performance issues arise
  - [ ] Use requestAnimationFrame() for visual updates
  - [ ] Benchmark: 10 panels × rapid typing = no lag
  - [ ] Keep immediate feedback as priority

## Dev Notes

### Event Listener Attachment
[Source: AC: 1, architecture/coding-standards.md]

**Option 1: Direct attachment (simple, current approach)**
```javascript
function initializeTextareaListeners() {
  document.querySelectorAll('.code-input').forEach(textarea => {
    const panelId = textarea.dataset.card;

    textarea.addEventListener('input', () => {
      onTextareaChange(panelId);
    });
  });
}
```

**Option 2: Event delegation (recommended for dynamic panels)**
```javascript
function initializeTextareaListeners() {
  // Single listener on document for all textareas
  document.addEventListener('input', (e) => {
    const textarea = e.target;

    // Check if target is a panel textarea
    if (textarea.classList.contains('code-input')) {
      const panelId = textarea.dataset.card;
      onTextareaChange(panelId);
    }
  });
}
```

**Recommendation:** Use event delegation (Option 2) for compatibility with dynamic panel creation (Epic 1).

### Textarea Change Handler
[Source: AC: 2, 3, 4, 5]

```javascript
// Handle textarea input event
function onTextareaChange(panelId) {
  const panel = cardStates[panelId];
  if (!panel) {
    console.warn(`Panel ${panelId} not found in cardStates`);
    return;
  }

  // Check if panel is stale (uses logic from Story 6.1)
  checkStaleness(panelId);

  // Update visual indicators immediately (Story 6.3)
  updateVisualIndicators(panelId);

  // Update UPDATE ALL button state (Story 6.4)
  updateAllButton();
}
```

### Integration with checkStaleness()
[Source: AC: 2, 3, 4, Story 6.1]

```javascript
// Check if panel is stale (from Story 6.1)
function checkStaleness(panelId) {
  const panel = cardStates[panelId];
  if (!panel) return false;

  const textarea = document.querySelector(`#${panelId} .code-input`);
  if (!textarea) return false;

  // Staleness only applies to playing panels
  if (!panel.playing) {
    panel.stale = false;
    return false;
  }

  // Compare current code to last-evaluated code
  const currentCode = textarea.value;
  const lastEvaluatedCode = panel.lastEvaluatedCode || '';

  const isStale = currentCode !== lastEvaluatedCode;
  panel.stale = isStale;

  return isStale;
}
```

### Complete Integration Flow
[Source: AC: 1, 2, 3, 4, 5]

```javascript
// main.js initialization
window.addEventListener('DOMContentLoaded', () => {
  initializeStrudel();
  initializeTextareaListeners(); // NEW: Story 6.5
  initializeUpdateAllButton();   // Story 6.4
  // ... other initialization
});

// Textarea listener setup (event delegation)
function initializeTextareaListeners() {
  document.addEventListener('input', (e) => {
    if (e.target.classList.contains('code-input')) {
      const panelId = e.target.dataset.card;
      onTextareaChange(panelId);
    }
  });

  console.log('Textarea listeners initialized (event delegation)');
}

// Textarea change handler
function onTextareaChange(panelId) {
  // 1. Check staleness (Story 6.1)
  checkStaleness(panelId);

  // 2. Update visual indicators (Story 6.3)
  updateVisualIndicators(panelId);

  // 3. Update UPDATE ALL button (Story 6.4)
  updateAllButton();
}
```

### Edge Case: Restore Original Code
[Source: AC: 4]

**Scenario:**
1. Panel playing with code: `note("c3").s("piano")`
2. User edits to: `note("c3 e3 g3").s("piano")` → **stale=true**
3. User undo (Ctrl+Z) back to: `note("c3").s("piano")` → **stale=false**

**Implementation:**
- Comparison uses strict equality: `currentCode !== lastEvaluatedCode`
- Whitespace matters: Adding/removing spaces changes staleness
- Undo restores exact original → staleness cleared

```javascript
// Example values
panel.lastEvaluatedCode = 'note("c3").s("piano")';
textarea.value = 'note("c3").s("piano")'; // Same → stale=false
textarea.value = 'note("c3 e3").s("piano")'; // Different → stale=true
textarea.value = 'note("c3").s("piano")'; // Restored → stale=false
```

### Edge Case: Paused Panels
[Source: AC: 3, Story 6.1]

**Scenario:**
1. Panel paused
2. User edits code
3. Staleness should remain **false** (no running pattern to differ from)

**Implementation:**
```javascript
function checkStaleness(panelId) {
  const panel = cardStates[panelId];

  // Paused panels cannot be stale
  if (!panel.playing) {
    panel.stale = false;
    return false;
  }

  // Only playing panels can be stale
  // ...
}
```

### Edge Case: Programmatic Updates
[Source: AC: 1, 2, Task 7]

**Scenario:**
- Settings restored from localStorage
- Textarea values set programmatically: `textarea.value = savedCode`
- Should NOT trigger staleness

**Implementation:**
- `input` event only fires on user interaction (typing, pasting)
- Programmatic `textarea.value = X` does NOT fire `input` event
- No special handling needed

```javascript
// Restore settings (does NOT trigger input event)
function restorePanelState() {
  settings.panels.forEach(panel => {
    const textarea = document.querySelector(`#${panel.id} .code-input`);
    if (textarea) {
      textarea.value = panel.code; // No input event fired
    }
  });
}

// User typing (DOES trigger input event)
// → onTextareaChange() called
// → checkStaleness() called
// → UI updates
```

### Performance Considerations
[Source: AC: 5, Task 8]

**Current Implementation:**
- No debounce: Immediate UI feedback
- Updates on every keystroke
- Minimal overhead: String comparison + CSS class toggle

**Performance Test:**
- 10 panels with rapid typing in one panel
- Expected: <1ms per keystroke (negligible)

**If performance issues arise:**
```javascript
// Optional: Debounce visual updates (NOT staleness check)
let visualUpdateTimeout;

function onTextareaChange(panelId) {
  // Always check staleness immediately
  checkStaleness(panelId);

  // Debounce visual updates (if needed)
  clearTimeout(visualUpdateTimeout);
  visualUpdateTimeout = setTimeout(() => {
    updateVisualIndicators(panelId);
    updateAllButton();
  }, 16); // ~60fps
}
```

**Recommendation:** Start with immediate updates. Only add debounce if user reports lag.

### Testing

Manual testing checklist:

- [ ] Type in playing panel → Stale indicator appears immediately
- [ ] Delete all edits, restore original → Stale indicator disappears
- [ ] Type in paused panel → Stale indicator does NOT appear
- [ ] Edit multiple panels → Each updates independently
- [ ] Rapid typing (10+ characters/second) → No UI lag
- [ ] Paste text → Stale indicator updates
- [ ] Undo (Ctrl+Z) → Staleness updates correctly
- [ ] Restore settings → Textareas update without triggering staleness
- [ ] Create new panel (Epic 1) → Input listener works
- [ ] UPDATE ALL button enables/disables as panels become stale

### Visual Update Flow Diagram
[Source: AC: 1, 2, 3, 4, 5]

```
User types in textarea
        ↓
`input` event fired
        ↓
onTextareaChange(panelId) called
        ↓
checkStaleness(panelId)
        ↓
Compare textarea.value vs. panel.lastEvaluatedCode
        ↓
    ┌─────────────────┐
    │  Same content   │  Different content
    ↓                 ↓
stale=false       stale=true
    ↓                 ↓
updateVisualIndicators(panelId)
    ↓                 ↓
Border: green     Border: yellow
Icon: hidden      Icon: ⚠️
Button: grayed    Button: UPDATE
        ↓
updateAllButton()
        ↓
UPDATE ALL enabled/disabled
```

### Comparison Logic Details
[Source: AC: 2, 3]

```javascript
// Comparison is strict and exact
const currentCode = textarea.value;
const lastEvaluatedCode = panel.lastEvaluatedCode || '';

// Strict equality (no trimming or normalization)
const isDifferent = currentCode !== lastEvaluatedCode;

// Examples:
'note("c3")' !== 'note("c3 e3")' // true (different)
'note("c3")' !== 'note("c3") ' // true (trailing space)
'note("c3")' !== 'note("c3")' // false (identical)
```

**Design Decision:** Use strict comparison (no normalization)
- **Pro:** Clear, predictable behavior
- **Pro:** User sees exact state of code vs. audio
- **Con:** Whitespace changes trigger staleness
- **Mitigation:** Users can undo to restore exact original

### Alternative: Normalized Comparison (NOT RECOMMENDED)
```javascript
// Alternative: Trim and normalize whitespace
const normalize = (code) => code.trim().replace(/\s+/g, ' ');
const isDifferent = normalize(currentCode) !== normalize(lastEvaluatedCode);

// Examples:
normalize('note("c3")') === normalize('note("c3") ') // true (same)
normalize('note("c3")') === normalize('note(  "c3"  )') // true (same)
```

**Recommendation:** Use strict comparison. Normalization adds complexity and may hide real changes.

## Dependencies

- Story 6.1: Staleness Detection Logic (provides `checkStaleness()`)
- Story 6.3: Visual Staleness Indicators (provides `updateVisualIndicators()`)
- Story 6.4: Top-Level UPDATE ALL Button (provides `updateAllButton()`)

## Related Stories

- Epic 1: Dynamic Panel Management (event delegation for dynamic panels)
- Story 6.2: Separate PAUSE and ACTIVATE Buttons (button updates on staleness)

## Change Log

| Date       | Version | Description                      | Author |
|------------|---------|----------------------------------|--------|
| 2025-11-16 | 1.0     | Initial story draft              | Claude |
| 2025-11-17 | 2.0     | Verified existing implementation | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None

### Completion Notes List

**Implementation Summary:**

Story 6.5 was ALREADY IMPLEMENTED prior to this development session. The existing event delegation pattern in main.js (lines 475-491) fully satisfies all acceptance criteria:

1. **Event Delegation** (main.js:475-491):
   - Document-level `input` event listener for all `.code-input` textareas
   - Uses `e.target.closest('.code-input')` to detect panel textareas
   - Extracts `panelId` from `data-card` attribute
   - Works automatically with dynamically created panels (Epic 1)

2. **Textarea Change Handling**:
   - Calls `checkStaleness(panelId)` to compare current vs. last-evaluated code
   - Uses strict equality comparison (Story 6.1)
   - Staleness only set for playing panels

3. **Immediate UI Updates**:
   - Calls `updateVisualIndicators(panelId)` for instant visual feedback
   - Calls `updateAllButton()` to update UPDATE ALL button state (Story 6.4)
   - No debounce or throttle - immediate response

4. **Edge Cases Handled**:
   - Paused panels: staleness remains false (handled in checkStaleness)
   - Programmatic updates: `textarea.value = code` does NOT fire input event
   - Restore original code: strict comparison clears staleness

**No changes were required** - the existing implementation already meets all requirements. This story was marked as Ready for Review with no code modifications.

### File List

- `src/main.js` (existing implementation) - Event delegation pattern at lines 475-491

## QA Results

_Results from QA Agent review of the completed story implementation_
